{
  
    
        "post0": {
            "title": "Spice up your Cycling Routes - with OpenStreetMap and Open Route Service",
            "content": "Introduction . Cycling is probably the only enjoyable (and safe!) mode of travel during this time. And what can be more enjoyable than cycling in the beautiful English countryside? Especially when the sun is out and you can really appreciate the perfect balance between manicure and wilderness, achieved through hundreds of years of hard work... . The other ingredient is all the historic buildings, memorials and small curiosities you can see along the way. During my previous trips, I often wondered how many of these points of interest are just a couple of minutes away from my route. Sometimes you even see an interesting architectural feature and wonder if it merits a digression. . OpenStreetMap is a treasure trove of community-sourced data that is available through an open API. With some time on my hands during the lockdown, I decided to explore what is possible with my limited Python skills. And the result was surprisingly usable, some may even say polished. So I decided to publish it for the benefit of my fellow cyclists. . Just one photo to keep you reading... . Preparation and basic mapping/routing . So, let&#39;s get into it. First, import the necessary modules (I strongly recommend to set up a separate conda virtual environment, so yo don&#39;t mess up the dependencies of your working environment): . from openrouteservice import client, directions import folium from shapely.geometry import LineString, Polygon, mapping, Point from shapely.ops import cascaded_union, transform import time import pyproj import networkx as nx import osmnx as ox import requests import ipywidgets as widgets . We will need to transform our coordinates data between lat/lon projection (in degrees) and distance projection (in meters). Here are pyproj helper functions to do that: . project_to_m = pyproj.Transformer.from_proj( pyproj.Proj(init=&#39;epsg:4326&#39;), # source coordinate system pyproj.Proj(init=&#39;epsg:32632&#39;)) # destination coordinate system project_to_deg = pyproj.Transformer.from_proj( pyproj.Proj(init=&#39;epsg:32632&#39;), pyproj.Proj(init=&#39;epsg:4326&#39;), # source coordinate system ) # destination coordinate system . def style_function(color): # To style data return lambda feature: dict(color=color, opacity=0.5, weight=4,) . Get OSM coordinates for the start and the finish of our trip. For this example, we are riding from London Bridge to a beautiful one-street (yes, it literally has one street) village of Chiddingstone, home of the Chiding Stone. . address_start = &#39;London Bridge Station&#39; address_end = &#39;Chiddingstone, Kent&#39; coord_start = ox.geocode(address_start) coord_end = ox.geocode(address_end) [coord_start, coord_end] . [(51.5050313, -0.0858923), (51.1858536, 0.1459325)] . Now let&#39;s request a regular cycling route between these points from OpenRouteService (ORS) and show it on the map. If you don&#39;t have an API key, you can request it at https://openrouteservice.org/sign-up . One thing to note is that mapping functions (Folium) accept input coordinates in Lat/Lon format, while the routing service accepts them in Lon/Lat format. So you need to reverse each coordinate tuple several times alog the way. . api_key = &#39;YOUR_ORS_KEY&#39; clnt = client.Client(key=api_key) map_route= folium.Map(tiles=&#39;OpenStreetMap&#39;, location=list(coord_start), #LAT-LON zoom_start=13.5, control_scale = True) # Create map popup_route = &quot;&lt;h4&gt;{0} route&lt;/h4&gt;&lt;hr&gt;&quot; &quot;&lt;strong&gt;Duration: &lt;/strong&gt;{1:.1f} mins&lt;br&gt;&quot; &quot;&lt;strong&gt;Distance: &lt;/strong&gt;{2:.3f} km&quot; # Request route coord_start_lon_lat = list(coord_start) coord_start_lon_lat.reverse() coord_end_lon_lat = list(coord_end) coord_end_lon_lat.reverse() coordinates = [coord_start_lon_lat, coord_end_lon_lat] #LON-LAT direction_params = {&#39;coordinates&#39;: coordinates, &#39;profile&#39;: &#39;cycling-regular&#39;, &#39;format_out&#39;: &#39;geojson&#39;, &#39;preference&#39;: &#39;recommended&#39;, &#39;geometry&#39;: &#39;true&#39;} regular_route = clnt.directions(**direction_params) # Direction request route_bbox = regular_route[&#39;features&#39;][0][&#39;bbox&#39;] # Build popup distance, duration = regular_route[&#39;features&#39;][0][&#39;properties&#39;][&#39;summary&#39;].values() popup = folium.map.Popup(popup_route.format(&#39;Regular&#39;, duration/60, distance/1000)) gj= folium.GeoJson(regular_route, name=&#39;Regular Route&#39;, style_function=style_function(&#39;blue&#39;)) .add_child(popup) .add_to(map_route) folium.Marker(list(reversed(coordinates[0])), popup=&#39;Start&#39;).add_to(map_route) folium.Marker(list(reversed(coordinates[1])), popup=&#39;End&#39;).add_to(map_route) map_route.fit_bounds([coord_start, coord_end], padding = (10,10)) map_route . Define the search area . So far, so good! But we don&#39;t just want to cycle from A to B. We want to see some interesting stuff along the way - maybe historical buildings, like castles and manors, tourist attractions etc. All without straying too far off our route. . So, let&#39;s say, we are going to search for Points of Interest (POI) that are no more than 500 meters from our regular route. To do that, we need to define a buffer around the route we generated: . This is a very simple function (that took me a long time to write!) that takes a list of coordinates(in degrees) and radius (in meters) and generates the buffer as a Polygon (in degrees) . def coordsToBufferPoints(coords, radius): polys = [] for c in coords: pointInitial = transform(project_to_m.transform, Point(c)) polys.append(pointInitial.buffer(radius)) polyBuffer = cascaded_union(polys) polyResult = transform(project_to_deg.transform, polyBuffer) return polyResult . Let&#39;s visualize the buffer on the map to make sure we got what we wanted . map_route_buffer = folium.Map(tiles=&#39;OpenStreetMap&#39;, location=list(coord_start), # LAT-LON zoom_start=13.5, control_scale=True) # Create map popup_route = &quot;&lt;h4&gt;{0} route&lt;/h4&gt;&lt;hr&gt;&quot; &quot;&lt;strong&gt;Duration: &lt;/strong&gt;{1:.1f} mins&lt;br&gt;&quot; &quot;&lt;strong&gt;Distance: &lt;/strong&gt;{2:.3f} km&quot; # Build popup distance, duration = regular_route[&#39;features&#39;][0][&#39;properties&#39;][&#39;summary&#39;].values( ) popup = folium.map.Popup(popup_route.format(&#39;Regular&#39;, duration/60, distance/1000)) gj = folium.GeoJson(regular_route, name=&#39;Regular Route&#39;, style_function=style_function(&#39;blue&#39;)) .add_child(popup) .add_to(map_route_buffer) routeCoords = regular_route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;coordinates&#39;] routeBuffer = coordsToBufferPoints(routeCoords, 500) gjBuffer = folium.GeoJson(routeBuffer, name=&#39;Regular Route&#39;, style_function=style_function(&#39;green&#39;)) .add_to(map_route_buffer) folium.Marker(list(reversed(coordinates[0])), popup=&#39;Start&#39;).add_to( map_route_buffer) folium.Marker(list(reversed(coordinates[1])), popup=&#39;End&#39;).add_to( map_route_buffer) map_route_buffer.fit_bounds([coord_start, coord_end], padding=(10, 10)) map_route_buffer . Great! Now, let&#39;s find these POIs. Here are the OSM tags we are interested in: . tagsRoute = {&#39;tourism&#39;: &#39;attraction&#39;, &#39;historic&#39;:True, &#39;building&#39;:&#39;castle&#39;} . Getting the POIs inside a polygon with OSMnx is just one function call: . routePOI = ox.pois_from_polygon(routeBuffer, tagsRoute) len(routePOI) . 78 . Oooh, 78 items! This will be a trip to remember! But upon closer inspection, a lot of these Points of Interest are... well, not so interesting. Actually, there is a lot of trash. . routePOI.head(10) . osmid geometry highway element_type crossing traffic_signals:direction maxspeed name rcn rcn_name ... roof:shape fortification_type water year source:rcn access:conditional ways alt_name:es fee payment:cash . 25620776 25620776 | POINT (-0.07639 51.50736) | NaN | node | NaN | NaN | NaN | Groups Entrance to the Tower | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 33149297 33149297 | POINT (-0.04698 51.46148) | mini_roundabout | node | NaN | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 33149335 33149335 | POINT (-0.05012 51.46602) | mini_roundabout | node | NaN | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 252602371 252602371 | POINT (-0.08826 51.50639) | NaN | node | NaN | NaN | NaN | London Bridge Experience | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 269863072 269863072 | POINT (-0.07434 51.50158) | NaN | node | NaN | NaN | NaN | Jacob | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 417304116 417304116 | POINT (-0.04868 51.46063) | NaN | node | NaN | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 420783219 420783219 | POINT (0.01109 51.40490) | NaN | node | NaN | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 445816914 445816914 | POINT (0.05284 51.33113) | NaN | node | NaN | NaN | NaN | The Wormstone | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 635975585 635975585 | POINT (-0.08670 51.50597) | NaN | node | NaN | NaN | NaN | London Bridge Experience | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 691387457 691387457 | POINT (-0.07848 51.50796) | NaN | node | NaN | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 10 rows Ã— 328 columns . Filter the POIs and update the route . So we need to filter this list and select some meaningful fields from hundreds of columns returned from OSM . routePOIFilter = routePOI[[&#39;element_type&#39;, &#39;name&#39;, &#39;historic&#39;, &#39;tourism&#39;, &#39;wikipedia&#39;, &#39;amenity&#39;, &#39;memorial&#39;, &#39;description&#39;, &#39;building&#39;, &#39;osmid&#39;, &#39;geometry&#39;]].dropna(thresh=5) routePOIFilter.head(10) . element_type name historic tourism wikipedia amenity memorial description building osmid geometry . 252602371 node | London Bridge Experience | NaN | attraction | en:The London Bridge Experience | NaN | NaN | NaN | NaN | 252602371 | POINT (-0.08826 51.50639) | . 269863072 node | Jacob | memorial | NaN | NaN | NaN | NaN | The circle dray horse | NaN | 269863072 | POINT (-0.07434 51.50158) | . 445816914 node | The Wormstone | archaeological_site | NaN | NaN | NaN | NaN | NaN | NaN | 445816914 | POINT (0.05284 51.33113) | . 635975585 node | London Bridge Experience | NaN | attraction | NaN | NaN | NaN | NaN | NaN | 635975585 | POINT (-0.08670 51.50597) | . 945300377 node | Scottish Martyrs monument | memorial | NaN | NaN | NaN | obelisk | NaN | NaN | 945300377 | POINT (-0.05313 51.46375) | . 963510071 node | Merchant Taylors&#39; School | memorial | NaN | NaN | NaN | blue_plaque | NaN | NaN | 963510071 | POINT (-0.09199 51.50833) | . 1048497151 node | Ernest Bevan | memorial | NaN | NaN | NaN | NaN | NaN | NaN | 1048497151 | POINT (-0.07796 51.50284) | . 1048497367 node | Samuel Bourne Bevington | memorial | NaN | NaN | NaN | NaN | NaN | NaN | 1048497367 | POINT (-0.07810 51.50290) | . 1657480036 node | Weardale Manor | ruins | NaN | NaN | NaN | NaN | NaN | NaN | 1657480036 | POINT (0.10145 51.24636) | . 1676037001 node | The Chiding Stone | archaeological_site | NaN | NaN | NaN | NaN | NaN | NaN | 1676037001 | POINT (0.14589 51.18535) | . Now, this is much better. But still, not all of these points really warrant a detour. So we will select a subset of them we are really interested in and will add them to the route. . We can make the whole process really seamless using the Jupyter interactive widget system. . checkboxList = [] columnsCheck = [&#39;historic&#39;, &#39;wikipedia&#39;, &#39;amenity&#39;, &#39;memorial&#39;, &#39;description&#39;] start = list(coord_start) end = list(coord_end) coordsUpdatedSorted = [] namesUpdatedSorted = [] def routeUpdate(b): global coordsUpdatedSorted, namesUpdatedSorted coordsUpdated = [] namesUpdated = [] distFromStart = [] for i in range(len(checkboxList)): if checkboxList[i].value == True: poiAdd = routePOIFilter.iloc[i] namesUpdated.append(poiAdd[&#39;name&#39;]) if poiAdd.element_type == &#39;node&#39;: coordAdd = [float(poiAdd.geometry.y), float(poiAdd.geometry.x)] else: coordAdd = [float(poiAdd.geometry.centroid.y), float(poiAdd.geometry.centroid.x)] coords = start + coordAdd dist = ox.distance.great_circle_vec(*coords) distFromStart.append(dist) coordsUpdated.append(coordAdd) # We need to sort any points we add to the route by distance from the starting point. # Otherwise, we will end with a hodge-podge of randomly selected points coordsUpdatedSorted = [c[1] for c in sorted( zip(distFromStart, coordsUpdated), key=lambda x: x[0])] coordsUpdatedSorted = [start] + coordsUpdatedSorted + [end] namesUpdatedSorted = [c[1] for c in sorted( zip(distFromStart, namesUpdated), key=lambda x: x[0])] namesUpdatedSorted = [address_start] + namesUpdatedSorted + [address_end] print(coordsUpdatedSorted) return coordsUpdatedSorted for i in range(len(routePOIFilter)): item = routePOIFilter.iloc[i] desc = str(item[&#39;name&#39;]) for c in columnsCheck: if type(item[c]) == str: desc = desc + &#39; &#39; + c+&#39;:&#39;+item[c] checkboxList.append(widgets.Checkbox( value=False, description=desc, disabled=False, indent=False, layout=widgets.Layout(width=&#39;100%&#39;) )) buttonUpdate = widgets.Button( description=&#39;Update route&#39;, disabled=False, button_style=&#39;&#39;, tooltip=&#39;Add selected POIs to the route&#39;, icon=&#39;update&#39; ) buttonUpdate.on_click(routeUpdate) widgetPOIcheck = widgets.VBox( checkboxList+[buttonUpdate], layout=widgets.Layout(width=&#39;100%&#39;)) widgetPOIcheck . [[51.5050313, -0.0858923], [51.503969155372445, -0.09325539799998009], [51.5015841, -0.0743414], [51.4637547, -0.0531279], [51.46308880000001, -0.0511468], [51.3510888399767, 0.030053528946478628], [51.3508184, 0.0373899], [51.33450105290082, 0.05585272964791204], [51.3311335, 0.0528395], [51.246361, 0.1014503], [51.18576100547525, 0.14227140698558516], [51.1853518, 0.1458905], [51.1858536, 0.1459325]] . The last step is to request the new route, which will include all selected points, and visualize it on the map again (including the POI markers): . map_route_updated = folium.Map(tiles=&#39;OpenStreetMap&#39;, location=(coordsUpdatedSorted[0]), # LAT-LON zoom_start=13.5, control_scale=True) # Create map popup_route = &quot;&lt;h4&gt;{0} route&lt;/h4&gt;&lt;hr&gt;&quot; &quot;&lt;strong&gt;Duration: &lt;/strong&gt;{1:.1f} mins&lt;br&gt;&quot; &quot;&lt;strong&gt;Distance: &lt;/strong&gt;{2:.3f} km&quot; # Request route coordinates_lon_lat = [[c[1], c[0]] for c in coordsUpdatedSorted] # LON-LAT direction_params = {&#39;coordinates&#39;: coordinates_lon_lat, &#39;profile&#39;: &#39;cycling-regular&#39;, &#39;format_out&#39;: &#39;geojson&#39;, &#39;preference&#39;: &#39;recommended&#39;, &#39;geometry&#39;: &#39;true&#39;} updated_route = clnt.directions(**direction_params) # Direction request route_bbox = regular_route[&#39;features&#39;][0][&#39;bbox&#39;] # Build popup distance, duration = updated_route[&#39;features&#39;][0][&#39;properties&#39;][&#39;summary&#39;].values( ) popup = folium.map.Popup(popup_route.format(&#39;Regular&#39;, duration/60, distance/1000)) gj = folium.GeoJson(regular_route, name=&#39;Regular Route&#39;, style_function=style_function(&#39;blue&#39;)) .add_child(popup) .add_to(map_route_updated) routeCoords = updated_route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;coordinates&#39;] for i in range(len(namesUpdatedSorted)): folium.Marker(coordsUpdatedSorted[i], popup=namesUpdatedSorted[i]).add_to( map_route_updated) map_route_updated.fit_bounds( [coordsUpdatedSorted[0], coordsUpdatedSorted[-1]], padding=(10, 10)) map_route_updated . You could notice that not all POIs are actually ON the route. This is not surprising, given some of them are in areas not reachable by bike. But they are all close enough to visit/observe. . You can even download the route as a GPX file to load into your navigator . body = {&quot;coordinates&quot;: coordinates_lon_lat, &quot;preference&quot;: &quot;recommended&quot;} headers = { &#39;Accept&#39;: &#39;application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8&#39;, &#39;Authorization&#39;: &#39;ORS_API_KEY&#39;, &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39; } call = requests.post( &#39;https://api.openrouteservice.org/v2/directions/cycling-regular/gpx&#39;, json=body, headers=headers) print(call.status_code, call.reason) print(&#39;GPX route received, &#39;, str(len(call.text)), &#39; bytes&#39;) . 200 OK GPX route received, 310806 bytes . with open(&#39;./route.gpx&#39;, &#39;w&#39;) as f: f.write(call.text) . That&#39;s it! Hope you did find it useful! .",
            "url": "https://kuznetsov-a.github.io/fastpages/cycling/python/openstreetmap/open%20route%20service/2020/06/05/cycling-POI.html",
            "relUrl": "/cycling/python/openstreetmap/open%20route%20service/2020/06/05/cycling-POI.html",
            "date": " â€¢ Jun 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Using open-source threat intelligence from Alienware OTX to prioritize the vulnerabilities remediation",
            "content": "Install/import libraries . #!pip install OTXv2 . import pandas as pd from pandas import json_normalize from OTXv2 import OTXv2, IndicatorTypes from datetime import datetime, timedelta . Define some helper functions . def indicators_by_type(pulses_df, unique = False): &#39;&#39;&#39;Aggregate the indicators in a DataFrame of pulses by type &#39;&#39;&#39; ind_types = [] ind_counts ={} ind_ids = {} for i, r in pulses_df.iterrows(): for ind in r[&#39;indicators&#39;]: #display (ind) if ind[&#39;type&#39;] in ind_types: if not unique: ind_counts [ind[&#39;type&#39;]] = ind_counts [ind[&#39;type&#39;]] +1 else: ind_ids[ind[&#39;type&#39;]].add(ind[&#39;id&#39;]) else: ind_types.append(ind[&#39;type&#39;]) if not unique: ind_counts [ind[&#39;type&#39;]] = 1 else: ind_ids[ind[&#39;type&#39;]] = set([ind[&#39;id&#39;]]) if not unique: return ind_counts else: for k,v in ind_ids.items(): ind_counts[k]=len(v) return ind_counts . def filter_indicators_by_type(pulses_df, filter_type): filtered_ind = [] for i, r in pulses_df.iterrows(): for ind in r[&#39;indicators&#39;]: # display (ind) if ind[&#39;type&#39;] == filter_type: filtered_ind.append(ind) return filtered_ind . def indicators_for_cve(CVE, unique=False): cve_pulse_df = json_normalize(otx.search_pulses(CVE)[&quot;results&quot;]) return indicators_by_type(cve_pulse_df, unique = unique) . Main section . from OTXv2 import OTXv2 from OTXv2 import IndicatorTypes otx = OTXv2(&quot;INSERT_YOUR_OTX_API_KEY&quot;) . Get all OTX pulses for the last 90 days . res = json_normalize(otx.getsince((datetime.now() - timedelta(days=90)).isoformat())) display(len(res)) res.columns . 1064 . Index([&#39;industries&#39;, &#39;tlp&#39;, &#39;description&#39;, &#39;created&#39;, &#39;tags&#39;, &#39;malware_families&#39;, &#39;modified&#39;, &#39;author_name&#39;, &#39;public&#39;, &#39;extract_source&#39;, &#39;references&#39;, &#39;targeted_countries&#39;, &#39;indicators&#39;, &#39;attack_ids&#39;, &#39;more_indicators&#39;, &#39;revision&#39;, &#39;adversary&#39;, &#39;id&#39;, &#39;name&#39;], dtype=&#39;object&#39;) . Get indicators summary for a specific CVE . indicators_for_cve(&#39;CVE-2020-10189&#39;) . {&#39;URL&#39;: 215, &#39;FileHash-SHA256&#39;: 700, &#39;hostname&#39;: 70, &#39;IPv4&#39;: 363, &#39;CVE&#39;: 41, &#39;FileHash-MD5&#39;: 225, &#39;YARA&#39;: 21, &#39;domain&#39;: 261, &#39;FileHash-SHA1&#39;: 105, &#39;email&#39;: 12} . From the list of pulses we downloaded, let&#39;s get all CVE indicators for vulnerabilities reported in 2019 or 2020. The reason to ecxclude oder vulnerabilities is that they will have a much longer timeline of reporting and will heavily skew the statistics . CVE_OTX = set([i[&#39;indicator&#39;] for i in filter_indicators_by_type(res, &#39;CVE&#39;) if &#39;2019&#39; in i[&#39;indicator&#39;] or &#39;2020&#39; in i[&#39;indicator&#39;]]) len(CVE_OTX) . 16 . Now let&#39;s get the unique indicators by type for each of these CVEs . CVE_stats = {} for CVE in CVE_OTX: CVE_stats[CVE] = indicators_for_cve(CVE, unique = True) . Worth checking that we have got the data for all CVEs, as some API calls can fail due to rate limiting . len(set(CVE_OTX)) . 16 . CVE_totals={} for c, s in CVE_stats.items(): CVE_totals[c]=sum(s.values()) CVE_totals_sorted = sorted (CVE_totals.items(), key = lambda x: x[1], reverse=True) . Sorting the CVE list by the total number of unique indicators reported . CVE_sorted = [c[0] for c in CVE_totals_sorted] totals_sorted = [c[1] for c in CVE_totals_sorted] . Group similar indicators types (e.g., file hashes, domains/hostnames) for clarity . ip_sorted = [] file_sorted = [] URL_sorted = [] domain_sorted = [] email_sorted = [] yara_sorted = [] for c in CVE_sorted: if &#39;IPv4&#39; in CVE_stats[c].keys(): ip_sorted.append(CVE_stats[c][&#39;IPv4&#39;]) else: ip_sorted.append(0) if &#39;email&#39; in CVE_stats[c].keys(): email_sorted.append(CVE_stats[c][&#39;email&#39;]) else: email_sorted.append(0) if &#39;URL&#39; in CVE_stats[c].keys(): URL_sorted.append(CVE_stats[c][&#39;URL&#39;]) else: URL_sorted.append(0) if &#39;YARA&#39; in CVE_stats[c].keys(): yara_sorted.append(CVE_stats[c][&#39;YARA&#39;]) else: yara_sorted.append(0) f=0 for t in [&#39;FileHash-SHA256&#39;, &#39;FileHash-MD5&#39;, &#39;FileHash-SHA1&#39;]: if t in CVE_stats[c].keys(): f = f + CVE_stats[c][t] file_sorted.append(f) d=0 for t in [&#39;hostname&#39;, &#39;domain&#39;]: if t in CVE_stats[c].keys(): d = d + CVE_stats[c][t] domain_sorted.append(d) . As the final step, we will plot our grouped, sorted data using plotly. Annotations are added manually to provide a short description for the top CVEs . import plotly.graph_objects as go fig = go.Figure( data=[ go.Bar(name=&#39;File hash&#39;, x=CVE_sorted, y=file_sorted), go.Bar(name=&#39;Domain/hostname&#39;, x=CVE_sorted, y=domain_sorted), go.Bar(name=&#39;IP&#39;, x=CVE_sorted, y=ip_sorted), go.Bar(name=&#39;URL&#39;, x=CVE_sorted, y=URL_sorted), go.Bar(name=&#39;Email&#39;, x=CVE_sorted, y=email_sorted), go.Bar(name=&#39;YARA Rule&#39;, x=CVE_sorted, y=yara_sorted) ]) # Change the bar mode fig.update_layout(width=1000, height=800, barmode=&#39;stack&#39;, title={ &#39;text&#39;: &quot;Alienvault OTX - TOP CVEs by unique IOCs, Q1 2020&quot;, &#39;y&#39;: 0.9, &#39;x&#39;: 0.5, &#39;xanchor&#39;: &#39;center&#39;, &#39;yanchor&#39;: &#39;top&#39;}, legend=dict(x=0.6, y=0.6) ) fig.update_yaxes(title_text=&quot;Count of unique linked IOC&quot;) fig.update_xaxes(title_text=&quot;CVE&quot;) fig.add_annotation(x=&#39;CVE-2019-2215&#39;, y= 750, text = &#39;Linux kernel use-after-free in binder.c&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2020-10189&#39;, y = 450, text = &#39;Zoho ManageEngine RCE&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-1653&#39;, y = 300, text = &#39;Cisco SMB VPN&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-1652&#39;, y = 300, text = &#39;Cisco SMB VPN&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2020-10198&#39;, y = 300, text = &#39;Mistype of CVE-2020-10189&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2020-10189&#39;, y = 450, text = &#39;Zoho ManageEngine RCE&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-1637&#39;, y = 300, text = &#39;Cisco WebEx RCE&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-11510&#39;, y = 200, text = &#39;Pulse Secure URI&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-0604&#39;, y = 300, text = &#39;MS SharePoint RCE&#39;, textangle = -90, showarrow=False) fig.add_annotation(x=&#39;CVE-2019-1579&#39;, y = 200, text = &#39;PAN OS RCE&#39;, textangle = -90, showarrow=False) fig.show() .",
            "url": "https://kuznetsov-a.github.io/fastpages/vulnerabilities%20management/risk%20management/threat%20intelligence/2020/03/31/OTX-CVE-Publish.html",
            "relUrl": "/vulnerabilities%20management/risk%20management/threat%20intelligence/2020/03/31/OTX-CVE-Publish.html",
            "date": " â€¢ Mar 31, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, itâ€™s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats.Â &#8617; . |",
          "url": "https://kuznetsov-a.github.io/fastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}